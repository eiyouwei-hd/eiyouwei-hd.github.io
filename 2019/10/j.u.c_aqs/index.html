<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>j.u.c_AQS | eiyouwei&#39;s home | Java Developer</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content=noodp><meta name=Description content=j.u.c_AQS><link rel=prev href=https://eiyouwei-hd.github.io/2019/10/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/><link rel=next href=https://eiyouwei-hd.github.io/2019/10/java%E5%AE%B9%E5%99%A8-hashmap/><link rel=canonical href=https://eiyouwei-hd.github.io/2019/10/j.u.c_aqs/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><meta name=twitter:card content=summary><meta name=twitter:title content=j.u.c_AQS><meta name=twitter:description content=j.u.c_AQS><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"j.u.c_AQS","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/eiyouwei-hd.github.io\/2019\/10\/j.u.c_aqs\/"},"image":{"@type":"ImageObject","url":"https:\/\/eiyouwei-hd.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"并发编程, J.U.C, AQS","wordcount":1803,"url":"https:\/\/eiyouwei-hd.github.io\/2019\/10\/j.u.c_aqs\/","datePublished":"2019-10-22T00:00:00\x2b00:00","dateModified":"2019-10-22T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"XXXX","logo":{"@type":"ImageObject","url":"https:\/\/eiyouwei-hd.github.io\/logo.png","width":127,"height":40}},"description":"j.u.c_AQS"}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css integrity="sha256-fdcFNFiBMrNfWL6OcAGQz6jDgNTRxnrLEd4vJYFWScE=" crossorigin=anonymous><link rel=stylesheet href=/css/lib/animate/animate.min.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class=navbar-header><a href=https://eiyouwei-hd.github.io/>eiyouwei&#39;s home | Java Developer</a></div><div class=navbar-menu><a class=menu-item href=https://eiyouwei-hd.github.io/posts/>Posts</a>
<a class=menu-item href=https://eiyouwei-hd.github.io/tags/>Tags</a>
<a class=menu-item href=https://eiyouwei-hd.github.io/categories/>Categories</a>
<a class=menu-item href=https://eiyouwei-hd.github.io/about/>About</a>
<a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a><a href=https://eiyouwei-hd.github.io/>eiyouwei&#39;s home | Java Developer</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://eiyouwei-hd.github.io/posts/>Posts</a>
<a class=menu-item href=https://eiyouwei-hd.github.io/tags/>Tags</a>
<a class=menu-item href=https://eiyouwei-hd.github.io/categories/>Categories</a>
<a class=menu-item href=https://eiyouwei-hd.github.io/about/>About</a></div></div></nav><main class=main><div class=container><article class=post-warp><h1 class="post-title animated flipInX">j.u.c_AQS</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://eiyouwei-hd.github.io/ rel=author><i class="fas fa-user-circle fa-fw"></i>eiyouwei&nbsp;</a>
<span class=post-category>收录于
<i class="far fa-folder fa-fw"></i><a href=https://eiyouwei-hd.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>并发编程</a></span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-10-22>2019-10-22</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>约 1803 字&nbsp;
<i class="far fa-clock fa-fw"></i>预计阅读 4 分钟&nbsp;</div></div><div class=post-content><a class=post-dummy-target id=aqs></a><h2>AQS</h2><ul><li><p>AQS：AbstractQueuedSynchronizer队列同步器，它是构建锁或者其他同步组件的基础框架</p></li><li><p>采用模板方法的设计模式，子类通过继承的方式，实现它的抽象方法来管理同步状态</p></li><li><p>定义了一个volatile int state变量作为共享资源，维护了一个FIFO同步队列：CLH；</p><ul><li><p>当线程获取资源成功，则执行临界区代码，否则就进入队列中等待；</p></li><li><p>执行完释放资源时，会通知同步队列中的等待线程来获取资源后出队并执行；</p></li><li><p>状态常量：</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571652697725.png alt=1571652697725 class=lazyload><figcaption class=image-caption>1571652697725</figcaption></figure></p></li><li><p>AQS提供了大量的模板方法来实现同步，主要是分为三类：</p><ul><li>独占式：同一时刻仅有一个线程持有同步状态</li><li>共享式：共享式在同一时刻可以有多个线程获取同步状态；</li><li>查询同步队列中的等待线程情况</li></ul></li></ul><a class=post-dummy-target id=独占式></a><h2>独占式</h2><ul><li><p>同步状态获取：acquire(int arg)；</p><ul><li>源码：</li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571642217922.png alt=1571642217922 class=lazyload><figcaption class=image-caption>1571642217922</figcaption></figure></p><ul><li>流程：</li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://www.javazhiyin.com/wp-content/uploads/2018/08/java9-1534474804.jpg alt=【死磕Java并发】—– j.u.c之aqs：同步状态的获取与释放 class=lazyload><figcaption class=image-caption>【死磕Java并发】—– J.U.C之AQS：同步状态的获取与释放</figcaption></figure></p><ul><li><p>先去尝试获取同步状态，若获取失败则，向CLH队列尾部插入一个节点，并自选等待，直到获取锁为止，</p></li><li><p>tryAcquire：尝试获取锁，获取成功则设置锁状态并返回true，否则返回false；需要自己实现：要保证线程安全的获取同步状态；</p></li><li><p>addWaiter：将当前线程加入到CLH同步队列尾部</p></li><li><p>acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571651927069.png alt=1571651927069 class=lazyload><figcaption class=image-caption>1571651927069</figcaption></figure></p><ul><li>当且仅当只有其前驱节点为头结点才能够尝试获取同步状态</li><li>获取同步状态成功，则将当前节点设为头节点</li><li><p>失败则继续等待</p></li><li><p>selfInterrupt：产生一个中断</p></li></ul></li><li><p>获取响应中断：</p><ul><li><p>acquireInterruptibly(int arg)：在等待获取同步状态时，如果当前线程被中断了，会<strong>立刻</strong>响应中断抛出异常InterruptedException</p></li><li><p>原因：AQS提供了acquire(int arg)方法以供独占式获取同步状态，但是该方法对中断不响应：即加入队列后不会移除，会一直等待获取同步状态；所以AQS提供了获取响应中断的模板方法</p></li><li><p>源码：</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571643910225.png alt=1571643910225 class=lazyload><figcaption class=image-caption>1571643910225</figcaption></figure></p><ul><li><p>先校验该线程是够已经中断，是的话直接抛异常：InterruptedException；否则，尝试去或同步状态tryAcquire，若失败执行doAcquireInterruptibly；</p></li><li><p>doAcquireInterruptibly(int arg)</p></li><li><p>与acquire方法差不多，不同的是acquire在自旋等待时返回是否被中断过，而doAcquireInterruptibly是直接抛异常；</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571644268632.png alt=1571644268632 class=lazyload><figcaption class=image-caption>1571644268632</figcaption></figure></p></li><li><p>超时获取：</p><ul><li><p>tryAcquireNanos(int arg,long nanos)：当前线程没有在指定时间被获取同步状态则会返回false；</p></li><li><p>响应中断存；</p></li><li><p>超时控制；</p></li></ul></li><li><p>源码：</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571644482722.png alt=1571644482722 class=lazyload><figcaption class=image-caption>1571644482722</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><span class=lnt>1
</span></pre></td><td class=lntd><pre class=chroma>![1571644567489](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1571644567489.png)</pre></td></tr></table></div></div><ul><li>流程图<br></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=https://www.javazhiyin.com/wp-content/uploads/2018/08/java6-1534474804.jpg alt=【死磕Java并发】—– j.u.c之aqs：同步状态的获取与释放 class=lazyload><figcaption class=image-caption>【死磕Java并发】—– J.U.C之AQS：同步状态的获取与释放</figcaption></figure></p><ul><li><p>释放同步状态</p><ul><li><p>release(int arg)：释放同步状态，唤醒后继节点</p></li><li><p>源码：</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571645095971.png alt=1571645095971 class=lazyload><figcaption class=image-caption>1571645095971</figcaption></figure></p></li></ul><a class=post-dummy-target id=共享式></a><h2>共享式</h2><ul><li><p>获取同步状态：</p><ul><li><p>acquireShared</p></li><li><p>tryAcquireShared：尝试获取同步状态，返回值为int，当其 &gt;= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。</p></li><li><p>源码：</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571650114343.png alt=1571650114343 class=lazyload><figcaption class=image-caption>1571650114343</figcaption></figure></p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571650149456.png alt=1571650149456 class=lazyload><figcaption class=image-caption>1571650149456</figcaption></figure></p></li><li><p>获取响应中断：acquireSharedInterruptibly</p></li><li><p>超时获取：tryAcquireSharedNanos</p></li><li><p>释放：</p><ul><li><p>releaseShared</p></li><li><p>可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过<strong>CAS+循环</strong>来完成的</p></li><li><p>源码：</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571650423041.png alt=1571650423041 class=lazyload><figcaption class=image-caption>1571650423041</figcaption></figure></p><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571650461541.png alt=1571650461541 class=lazyload><figcaption class=image-caption>1571650461541</figcaption></figure></p></li></ul><a class=post-dummy-target id=线程阻塞or唤醒></a><h2>线程阻塞or唤醒</h2><ul><li><p>当获取同步方法失败后需要阻塞当前线程并自旋等待：</p><ul><li><p>shouldParkAfterFailedAcquire：根据前驱节点，判断当前线程是否需要阻塞，检查逻辑：</p></li><li><p>前驱节点状态为SINNAL，则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞</p></li><li><p>前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</p></li><li><p>非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false</p></li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571651865192.png alt=1571651865192 class=lazyload><figcaption class=image-caption>1571651865192</figcaption></figure></p><ul><li>parkAndCheckInterrupt：阻塞当前线程<br></li></ul></li><li><p>当线程释放同步状态时，需要唤醒后续节点：</p><ul><li>unparkSuccessor</li></ul><p><figure><img src=/images/loading.svg data-sizes=auto data-src=C:UserslenovoAppDataRoamingTyporatypora-user-images1571652382011.png alt=1571652382011 class=lazyload><figcaption class=image-caption>1571652382011</figcaption></figure></p><ul><li><p>当前节点状态&lt;0，则设置为0；</p></li><li><p>后继节点为null || 状&gt;0（超时或被中断了）</p></li><li><p>从tail尾节点开始找，找到第一个可用节点，唤醒他；</p></li></ul></li></ul><a class=post-dummy-target id=总结></a><h2>总结</h2><ul><li>AQS是j.u.c包实现同步的基础工具，使用了模板方法的设计模式，提供了独占、共享、中断、超时等特性的方法；</li><li>AQS的子类可以定义不同的资源实现不同特性的方法，比如后文要写，的ReentrantLock，定义state为0时可以获取资源并置为1。若已获得资源则不断+1，在释放资源时减1，直至减为0；再比如CountDownLatch、CyclicBarrier、Semaphore等等；</li></ul><a class=post-dummy-target id=ref></a><h2>REF</h2><p><a href=https://www.javazhiyin.com/15063.html>https://www.javazhiyin.com/15063.html</a></p><p><a href=https://www.javazhiyin.com/15242.html>https://www.javazhiyin.com/15242.html</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>本文于 2019-10-22 更新</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://eiyouwei-hd.github.io/2019/10/j.u.c_aqs/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://eiyouwei-hd.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/><i class="fas fa-tag fa-fw"></i>并发编程</a></span>
<span class=tag><a href=https://eiyouwei-hd.github.io/tags/j.u.c/><i class="fas fa-tag fa-fw"></i>J.U.C</a></span>
<span class=tag><a href=https://eiyouwei-hd.github.io/tags/aqs/><i class="fas fa-tag fa-fw"></i>AQS</a></span></section><section><span><a href=javascript:window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://eiyouwei-hd.github.io/>主页</a></span></section></div><div class=post-nav><a href=https://eiyouwei-hd.github.io/2019/10/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/ class=prev rel=prev title=java内存模型><i class="fas fa-angle-left fa-fw"></i>java内存模型</a>
<a href=https://eiyouwei-hd.github.io/2019/10/java%E5%AE%B9%E5%99%A8-hashmap/ class=next rel=next title=HashMap之100问>HashMap之100问<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:"2019-10-22 00:00:00 \x2b0000 UTC",title:"j.u.c_AQS",clientID:"e38fc798c72a7e4e1386",clientSecret:"e151aa3b7b98d3cfaa1f096b88fdd7897e2c8007",repo:"xiaoheiAh.github.io",owner:"xiaoheiAh",admin:["xiaoheiAh"],body:decodeURI(location.href)});gitalk.render("gitalk-container");</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2019</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://eiyouwei-hd.github.io/>eiyouwei</a></span><span class=license>&nbsp;|&nbsp;<a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer><script src=/js/lib/jquery/jquery.slim.min.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><script src=/js/blog.min.js></script></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a></body></html>